#!/usr/bin/env python3
"""
ObsidianEmitter - Emit watcher events to Obsidian vault as Markdown files.

Transforms WatcherEvents into formatted Markdown notes compatible with
Obsidian, supporting templates, frontmatter, and folder organization.
"""

from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any, Callable, Optional
import json
import re
import logging

from base_watcher import WatcherEvent, EventType

logger = logging.getLogger(__name__)


@dataclass
class EmitterConfig:
    """
    Configuration for ObsidianEmitter.
    
    Attributes:
        vault_path: Path to Obsidian vault root
        default_folder: Default folder for events (relative to vault)
        file_pattern: Pattern for event file names (supports {placeholders})
        use_daily_folders: Group events into daily folders
        include_frontmatter: Add YAML frontmatter to notes
        template: Custom template string (None = default)
        folder_mapping: Map event types/sources to specific folders
        max_events_per_file: Append to file until limit, then create new
        link_related: Create wikilinks to related notes
    """
    vault_path: str = ""
    default_folder: str = "watcher-events"
    file_pattern: str = "{date}_{watcher}_{event_id}"
    use_daily_folders: bool = True
    include_frontmatter: bool = True
    template: Optional[str] = None
    folder_mapping: dict = field(default_factory=dict)
    max_events_per_file: int = 1
    link_related: bool = True


DEFAULT_TEMPLATE = """---
{frontmatter}
---

# {title}

**Event Type:** {event_type}
**Source:** {source}
**Timestamp:** {timestamp}
**Watcher:** {watcher_name}

## Details

{details}

{metadata_section}

---
*Generated by BaseWatcher Framework*
"""

DAILY_LOG_TEMPLATE = """---
{frontmatter}
---

# {title}

## Events

{events_list}

---
*Generated by BaseWatcher Framework*
"""


class ObsidianEmitter:
    """
    Emits watcher events to Obsidian vault as Markdown files.
    
    Supports multiple output strategies:
    - Individual files per event
    - Daily aggregated logs
    - Custom templates
    - Folder routing based on event type/source
    
    Example:
        config = EmitterConfig(
            vault_path="/path/to/obsidian/vault",
            default_folder="automation/events",
            use_daily_folders=True
        )
        
        emitter = ObsidianEmitter(config)
        
        # Connect to watcher
        watcher.on_event(emitter.emit)
        
        # Or use with registry
        registry.on_event(emitter.emit)
    """
    
    def __init__(self, config: EmitterConfig):
        self.config = config
        self._vault_path = Path(config.vault_path).resolve()
        self._template = config.template or DEFAULT_TEMPLATE
        self._formatters: dict[EventType, Callable[[WatcherEvent], str]] = {}
        self._daily_counts: dict[str, int] = {}
        
        # Ensure vault exists
        if not self._vault_path.exists():
            raise FileNotFoundError(f"Vault path does not exist: {self._vault_path}")
    
    def set_formatter(
        self, 
        event_type: EventType, 
        formatter: Callable[[WatcherEvent], str]
    ) -> "ObsidianEmitter":
        """
        Set custom formatter for specific event types.
        
        Args:
            event_type: Event type to format
            formatter: Function(event) -> markdown_string
            
        Returns:
            Self for chaining
        """
        self._formatters[event_type] = formatter
        return self
    
    def emit(self, event: WatcherEvent) -> Path:
        """
        Emit an event to the Obsidian vault.
        
        Args:
            event: WatcherEvent to emit
            
        Returns:
            Path to created/updated file
        """
        folder = self._resolve_folder(event)
        filename = self._resolve_filename(event)
        
        # Ensure folder exists
        folder.mkdir(parents=True, exist_ok=True)
        
        file_path = folder / f"{filename}.md"
        
        # Generate content
        content = self._format_event(event)
        
        # Write or append
        if file_path.exists() and self.config.max_events_per_file > 1:
            existing = file_path.read_text(encoding="utf-8")
            count = self._daily_counts.get(str(file_path), 1)
            
            if count < self.config.max_events_per_file:
                content = self._append_to_daily(existing, event)
                self._daily_counts[str(file_path)] = count + 1
            else:
                # Create new file with suffix
                file_path = folder / f"{filename}_{count + 1}.md"
                self._daily_counts[str(file_path)] = 1
        
        file_path.write_text(content, encoding="utf-8")
        logger.info(f"Emitted event to: {file_path}")
        
        return file_path
    
    def emit_batch(self, events: list[WatcherEvent]) -> list[Path]:
        """
        Emit multiple events, optionally aggregating.
        
        Args:
            events: List of events to emit
            
        Returns:
            List of created file paths
        """
        paths = []
        for event in events:
            path = self.emit(event)
            paths.append(path)
        return paths
    
    def _resolve_folder(self, event: WatcherEvent) -> Path:
        """Determine output folder for event."""
        base_folder = self.config.default_folder
        
        # Check folder mapping
        mapping = self.config.folder_mapping
        
        # Check by event type
        if event.event_type.value in mapping:
            base_folder = mapping[event.event_type.value]
        
        # Check by watcher name
        if event.watcher_name in mapping:
            base_folder = mapping[event.watcher_name]
        
        # Check by source pattern
        for pattern, folder in mapping.items():
            if "*" in pattern and self._match_glob(event.source, pattern):
                base_folder = folder
                break
        
        folder = self._vault_path / base_folder
        
        # Add daily subfolder if configured
        if self.config.use_daily_folders:
            date_folder = event.timestamp.strftime("%Y/%m-%B/%d")
            folder = folder / date_folder
        
        return folder
    
    def _resolve_filename(self, event: WatcherEvent) -> str:
        """Generate filename for event."""
        pattern = self.config.file_pattern
        
        # Available placeholders
        replacements = {
            "date": event.timestamp.strftime("%Y-%m-%d"),
            "time": event.timestamp.strftime("%H-%M-%S"),
            "datetime": event.timestamp.strftime("%Y-%m-%d_%H-%M-%S"),
            "event_id": event.event_id,
            "event_type": event.event_type.value,
            "watcher": self._sanitize_filename(event.watcher_name),
            "source": self._sanitize_filename(Path(event.source).stem if "/" in event.source or "\\" in event.source else event.source),
        }
        
        filename = pattern
        for key, value in replacements.items():
            filename = filename.replace(f"{{{key}}}", str(value))
        
        return self._sanitize_filename(filename)
    
    def _format_event(self, event: WatcherEvent) -> str:
        """Format event as Markdown."""
        # Check for custom formatter
        if event.event_type in self._formatters:
            return self._formatters[event.event_type](event)
        
        # Build frontmatter
        frontmatter = self._build_frontmatter(event)
        
        # Build title
        title = self._build_title(event)
        
        # Build details section
        details = self._build_details(event)
        
        # Build metadata section
        metadata_section = self._build_metadata(event)
        
        # Apply template
        content = self._template.format(
            frontmatter=frontmatter,
            title=title,
            event_type=event.event_type.value.title(),
            source=event.source,
            timestamp=event.timestamp.strftime("%Y-%m-%d %H:%M:%S"),
            watcher_name=event.watcher_name,
            details=details,
            metadata_section=metadata_section
        )
        
        return content
    
    def _build_frontmatter(self, event: WatcherEvent) -> str:
        """Build YAML frontmatter."""
        if not self.config.include_frontmatter:
            return ""
        
        fm = {
            "event_id": event.event_id,
            "event_type": event.event_type.value,
            "source": event.source,
            "watcher": event.watcher_name,
            "created": event.timestamp.isoformat(),
            "tags": [
                f"watcher/{event.watcher_name}",
                f"event/{event.event_type.value}"
            ]
        }
        
        lines = []
        for key, value in fm.items():
            if isinstance(value, list):
                lines.append(f"{key}:")
                for item in value:
                    lines.append(f"  - {item}")
            else:
                lines.append(f"{key}: {value}")
        
        return "\n".join(lines)
    
    def _build_title(self, event: WatcherEvent) -> str:
        """Build event title."""
        type_emoji = {
            EventType.CREATED: "âœ¨",
            EventType.MODIFIED: "ðŸ“",
            EventType.DELETED: "ðŸ—‘ï¸",
            EventType.ERROR: "âŒ",
            EventType.INFO: "â„¹ï¸",
            EventType.WARNING: "âš ï¸",
            EventType.CUSTOM: "ðŸ””"
        }
        
        emoji = type_emoji.get(event.event_type, "ðŸ“Œ")
        source_name = Path(event.source).name if "/" in event.source or "\\" in event.source else event.source
        
        return f"{emoji} {event.event_type.value.title()}: {source_name}"
    
    def _build_details(self, event: WatcherEvent) -> str:
        """Build details section based on event data."""
        data = event.data
        
        if not data:
            return "_No additional details_"
        
        if isinstance(data, dict):
            lines = []
            
            # Special handling for file events
            if "path" in data:
                lines.append(f"- **Path:** `{data['path']}`")
            if "filename" in data:
                lines.append(f"- **Filename:** {data['filename']}")
            if "extension" in data:
                lines.append(f"- **Type:** {data['extension'] or 'No extension'}")
            if "size" in data:
                lines.append(f"- **Size:** {self._format_size(data['size'])}")
            
            # Special handling for API events
            if "url" in data:
                lines.append(f"- **URL:** `{data['url']}`")
            if "changes" in data and data["changes"]:
                lines.append("\n### Changes")
                for field, change in data["changes"].items():
                    lines.append(f"- **{field}:** `{change.get('old')}` â†’ `{change.get('new')}`")
            if "response" in data:
                lines.append("\n### Response")
                lines.append("```json")
                lines.append(json.dumps(data["response"], indent=2)[:1000])
                lines.append("```")
            
            # Generic dict handling for remaining fields
            handled = {"path", "filename", "extension", "size", "url", "changes", "response", "mtime"}
            for key, value in data.items():
                if key not in handled:
                    lines.append(f"- **{key.replace('_', ' ').title()}:** {value}")
            
            return "\n".join(lines) if lines else "_No additional details_"
        
        # Non-dict data
        return f"```\n{data}\n```"
    
    def _build_metadata(self, event: WatcherEvent) -> str:
        """Build metadata section."""
        if not event.metadata:
            return ""
        
        lines = ["## Metadata", ""]
        for key, value in event.metadata.items():
            lines.append(f"- **{key}:** {value}")
        
        return "\n".join(lines)
    
    def _append_to_daily(self, existing: str, event: WatcherEvent) -> str:
        """Append event to existing daily log."""
        entry = self._format_log_entry(event)
        
        # Find the events list section and append
        if "## Events" in existing:
            parts = existing.split("---\n*Generated")
            main_content = parts[0]
            main_content += f"\n{entry}\n"
            return main_content + "---\n*Generated" + parts[1] if len(parts) > 1 else main_content
        
        return existing + f"\n\n{entry}"
    
    def _format_log_entry(self, event: WatcherEvent) -> str:
        """Format event as a log entry for daily files."""
        time = event.timestamp.strftime("%H:%M:%S")
        source = Path(event.source).name if "/" in event.source or "\\" in event.source else event.source
        
        return f"- **{time}** | {event.event_type.value.upper()} | {source} | {event.watcher_name}"
    
    @staticmethod
    def _sanitize_filename(name: str) -> str:
        """Remove invalid filename characters."""
        # Remove or replace invalid chars
        invalid = r'<>:"/\\|?*'
        for char in invalid:
            name = name.replace(char, "_")
        # Collapse multiple underscores
        name = re.sub(r"_+", "_", name)
        # Trim
        return name.strip("_")[:100]
    
    @staticmethod
    def _match_glob(text: str, pattern: str) -> bool:
        """Simple glob matching."""
        import fnmatch
        return fnmatch.fnmatch(text, pattern)
    
    @staticmethod
    def _format_size(size: int) -> str:
        """Format file size in human-readable form."""
        for unit in ["B", "KB", "MB", "GB"]:
            if size < 1024:
                return f"{size:.1f} {unit}"
            size /= 1024
        return f"{size:.1f} TB"


# Convenience function
def emit_to_vault(
    vault_path: str,
    folder: str = "watcher-events",
    use_daily_folders: bool = True
) -> ObsidianEmitter:
    """
    Create an emitter with common defaults.
    
    Args:
        vault_path: Path to Obsidian vault
        folder: Folder for events
        use_daily_folders: Group by date
        
    Returns:
        Configured ObsidianEmitter
    """
    config = EmitterConfig(
        vault_path=vault_path,
        default_folder=folder,
        use_daily_folders=use_daily_folders
    )
    return ObsidianEmitter(config)
