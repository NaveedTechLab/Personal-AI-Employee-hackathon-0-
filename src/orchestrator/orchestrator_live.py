#!/usr/bin/env python3
"""
AI Employee - Live Orchestrator
Reads Needs_Action files, creates Plans, and routes to Pending_Approval.
This is the "brain" that processes incoming items from all watchers.

Flow: Needs_Action → Plans → Pending_Approval (HITL) → Approved → Done
"""

import os
import re
import time
import signal
import shutil
from datetime import datetime
from pathlib import Path
from dotenv import load_dotenv

load_dotenv()

VAULT_DIR = Path(os.getenv("VAULT_DIR", "./demo_vault"))
NEEDS_ACTION_DIR = VAULT_DIR / "Needs_Action"
PLANS_DIR = VAULT_DIR / "Plans"
PENDING_APPROVAL_DIR = VAULT_DIR / "Pending_Approval"
IN_PROGRESS_DIR = VAULT_DIR / "In_Progress"
DONE_DIR = VAULT_DIR / "Done"
LOGS_DIR = VAULT_DIR / "Logs"
POLL_INTERVAL = 10  # seconds

processed_items = set()
running = True


def signal_handler(sig, frame):
    global running
    print("\n[Orchestrator] Shutting down...")
    running = False


signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)


def log_activity(action, details=""):
    LOGS_DIR.mkdir(parents=True, exist_ok=True)
    log_file = LOGS_DIR / f"orchestrator_{datetime.now().strftime('%Y%m%d')}.log"
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open(log_file, "a", encoding="utf-8") as f:
        f.write(f"[{timestamp}] {action}: {details}\n")


def detect_action_type(content, filename):
    """Determine what kind of action this item needs."""
    content_lower = content.lower()
    filename_lower = filename.lower()

    if "invoice" in content_lower or "invoice" in filename_lower:
        return "invoice"
    elif "payment" in content_lower or "payment" in filename_lower:
        return "payment"
    elif filename.startswith("EMAIL_") or "email" in filename_lower:
        return "email_reply"
    elif filename.startswith("WA_") or "whatsapp" in filename_lower:
        return "whatsapp_reply"
    elif filename.startswith("FILE_"):
        return "file_process"
    elif "social" in content_lower or "linkedin" in content_lower or "twitter" in content_lower:
        return "social_post"
    elif "meeting" in content_lower or "calendar" in content_lower:
        return "calendar"
    else:
        return "general"


def detect_priority(content, filename):
    """Determine priority from content."""
    high_keywords = ["urgent", "asap", "critical", "payment", "invoice", "deadline"]
    content_lower = content.lower()
    for kw in high_keywords:
        if kw in content_lower:
            return "HIGH"
    return "NORMAL"


def create_plan(action_file, content, action_type, priority):
    """Create a Plan file for the action item."""
    PLANS_DIR.mkdir(parents=True, exist_ok=True)
    now = datetime.now()
    plan_name = f"PLAN_{action_file.stem}_{now.strftime('%H%M%S')}.md"

    # Build plan based on action type
    steps = get_plan_steps(action_type, content)

    plan_content = f"""---
created: {now.isoformat()}
source: {action_file.name}
action_type: {action_type}
priority: {priority}
status: pending_approval
---

# Plan: {action_file.stem}

## Source
- **File**: {action_file.name}
- **Type**: {action_type}
- **Priority**: {priority}
- **Created**: {now.strftime('%Y-%m-%d %H:%M:%S')}

## Proposed Steps
{steps}

## Approval Required
- [ ] Review the proposed action above
- [ ] Move this file to `Approved/` to execute, or `Rejected/` to cancel

---
*Generated by AI Employee Orchestrator*
"""

    plan_path = PLANS_DIR / plan_name
    plan_path.write_text(plan_content, encoding="utf-8")
    log_activity("PLAN_CREATED", f"{plan_name} for {action_file.name}")
    print(f"  [PLAN] Created: {plan_name}")
    return plan_path


def get_plan_steps(action_type, content):
    """Generate plan steps based on action type."""
    if action_type == "invoice":
        return """1. Parse invoice details from the message
2. Look up client rate in [[Accounting/Rates]]
3. Draft invoice document
4. **[APPROVAL NEEDED]** Send invoice via Email MCP
5. Log transaction in [[Accounting/Bank_Transactions]]
"""
    elif action_type == "payment":
        return """1. Parse payment details
2. Verify against known payees
3. **[APPROVAL NEEDED]** Execute payment via Browser Payment MCP
4. Log transaction in [[Accounting/Bank_Transactions]]
"""
    elif action_type == "email_reply":
        return """1. Analyze email content and context
2. Draft appropriate reply
3. **[APPROVAL NEEDED]** Send reply via Email MCP
4. Move original to Done/
"""
    elif action_type == "whatsapp_reply":
        return """1. Analyze WhatsApp message context
2. Draft appropriate reply
3. **[APPROVAL NEEDED]** Send reply via WhatsApp
4. Move original to Done/
"""
    elif action_type == "social_post":
        return """1. Draft social media content
2. Select target platforms (LinkedIn/Twitter)
3. **[APPROVAL NEEDED]** Post via Social MCP
4. Log posting activity
"""
    elif action_type == "calendar":
        return """1. Parse meeting/event details
2. Check calendar availability
3. **[APPROVAL NEEDED]** Create calendar event via Calendar MCP
4. Send confirmation
"""
    elif action_type == "file_process":
        return """1. Analyze file type and content
2. Determine appropriate action (categorize, extract, archive)
3. Route to appropriate handler
4. Move to Done/ when processed
"""
    else:
        return """1. Review the incoming item
2. Determine appropriate response
3. **[APPROVAL NEEDED]** Execute proposed action
4. Log and archive
"""


def route_to_approval(plan_path, action_file, action_type, priority):
    """Copy plan to Pending_Approval for HITL review."""
    PENDING_APPROVAL_DIR.mkdir(parents=True, exist_ok=True)

    # Create approval file with action prefix
    prefix_map = {
        "invoice": "INVOICE",
        "payment": "PAYMENT",
        "email_reply": "REPLY",
        "whatsapp_reply": "REPLY",
        "social_post": "SOCIAL",
        "calendar": "CALENDAR",
        "file_process": "FILE",
        "general": "ACTION",
    }
    prefix = prefix_map.get(action_type, "ACTION")
    approval_name = f"{prefix}_{action_file.stem}.md"

    # Read plan content and add approval instructions
    plan_content = plan_path.read_text(encoding="utf-8")

    approval_path = PENDING_APPROVAL_DIR / approval_name
    approval_path.write_text(plan_content, encoding="utf-8")

    log_activity("ROUTED_TO_APPROVAL", f"{approval_name}")
    print(f"  [APPROVAL] Routed: {approval_name} -> Pending_Approval/")
    return approval_path


def process_needs_action_item(action_file):
    """Process a single Needs_Action item through the orchestration pipeline."""
    try:
        content = action_file.read_text(encoding="utf-8")
        action_type = detect_action_type(content, action_file.name)
        priority = detect_priority(content, action_file.name)

        print(f"\n  [ORCHESTRATOR] Processing: {action_file.name}")
        print(f"    Type: {action_type} | Priority: {priority}")

        # Step 1: Create plan
        plan_path = create_plan(action_file, content, action_type, priority)

        # Step 2: Route to approval (HITL)
        route_to_approval(plan_path, action_file, action_type, priority)

        # Step 3: Move original to In_Progress
        in_progress_path = IN_PROGRESS_DIR / "local" / action_file.name
        in_progress_path.parent.mkdir(parents=True, exist_ok=True)
        if not in_progress_path.exists():
            shutil.move(str(action_file), str(in_progress_path))
            log_activity("MOVED_TO_IN_PROGRESS", f"{action_file.name}")
            print(f"  [MOVED] {action_file.name} -> In_Progress/local/")

    except Exception as e:
        log_activity("ERROR", f"Processing {action_file.name}: {e}")
        print(f"  [ERROR] {action_file.name}: {e}")


def scan_needs_action():
    """Scan all Needs_Action subdirectories for unprocessed items."""
    if not NEEDS_ACTION_DIR.exists():
        return

    for subdir in NEEDS_ACTION_DIR.iterdir():
        if subdir.is_dir():
            for f in sorted(subdir.glob("*.md")):
                item_key = f"{subdir.name}/{f.name}"
                if item_key not in processed_items:
                    process_needs_action_item(f)
                    processed_items.add(item_key)

    # Also check root-level files in Needs_Action
    for f in sorted(NEEDS_ACTION_DIR.glob("*.md")):
        if f.name not in processed_items:
            process_needs_action_item(f)
            processed_items.add(f.name)


def update_dashboard_stats():
    """Update Dashboard.md with current queue stats."""
    dashboard = VAULT_DIR / "Dashboard.md"
    if not dashboard.exists():
        return

    try:
        content = dashboard.read_text(encoding="utf-8")

        # Count items in each stage
        needs_count = sum(1 for _ in NEEDS_ACTION_DIR.rglob("*.md")) if NEEDS_ACTION_DIR.exists() else 0
        plans_count = sum(1 for _ in PLANS_DIR.glob("*.md")) if PLANS_DIR.exists() else 0
        pending_count = sum(1 for _ in PENDING_APPROVAL_DIR.glob("*.md")) if PENDING_APPROVAL_DIR.exists() else 0
        done_count = sum(1 for _ in DONE_DIR.glob("*.md")) if DONE_DIR.exists() else 0

        # Update orchestrator status in dashboard
        content = re.sub(
            r"\| Orchestrator\s*\|.*\|.*\|",
            f"| Orchestrator | Running | {datetime.now().strftime('%H:%M:%S')} |",
            content
        )

        dashboard.write_text(content, encoding="utf-8")
    except Exception:
        pass


def main():
    # Ensure directories
    for d in [NEEDS_ACTION_DIR, PLANS_DIR, PENDING_APPROVAL_DIR,
              IN_PROGRESS_DIR / "local", IN_PROGRESS_DIR / "cloud",
              DONE_DIR, LOGS_DIR]:
        d.mkdir(parents=True, exist_ok=True)

    # Mark existing items as processed on startup
    if NEEDS_ACTION_DIR.exists():
        for subdir in NEEDS_ACTION_DIR.iterdir():
            if subdir.is_dir():
                for f in subdir.glob("*.md"):
                    processed_items.add(f"{subdir.name}/{f.name}")
        for f in NEEDS_ACTION_DIR.glob("*.md"):
            processed_items.add(f.name)

    print("=" * 60)
    print("  AI Employee - Orchestrator LIVE MODE")
    print(f"  Needs_Action: {NEEDS_ACTION_DIR}")
    print(f"  Plans: {PLANS_DIR}")
    print(f"  Pending_Approval: {PENDING_APPROVAL_DIR}")
    print(f"  Poll Interval: {POLL_INTERVAL}s")
    print("=" * 60)
    print()

    log_activity("STARTED", f"Orchestrator started. {len(processed_items)} existing items skipped.")

    cycle = 0
    while running:
        scan_needs_action()

        cycle += 1
        if cycle % 6 == 0:  # Every ~60 seconds
            update_dashboard_stats()

        for _ in range(POLL_INTERVAL):
            if not running:
                break
            time.sleep(1)

    log_activity("STOPPED", "Orchestrator stopped.")
    print("[Orchestrator] Stopped.")


if __name__ == "__main__":
    main()
