#!/usr/bin/env python3
"""
AI Employee - Live Scheduler
Runs timed tasks: CEO Monday Briefing, Subscription Audit, Dashboard refresh.
Uses simple polling-based scheduling (no external cron dependency).
"""

import os
import time
import signal
from datetime import datetime, timedelta
from pathlib import Path
from dotenv import load_dotenv

load_dotenv()

VAULT_DIR = Path(os.getenv("VAULT_DIR", "./demo_vault"))
LOGS_DIR = VAULT_DIR / "Logs"

running = True
CHECK_INTERVAL = 60  # Check every 60 seconds


def signal_handler(sig, frame):
    global running
    print("\n[Scheduler] Shutting down...")
    running = False


signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)


def log_activity(action, details=""):
    LOGS_DIR.mkdir(parents=True, exist_ok=True)
    log_file = LOGS_DIR / f"scheduler_{datetime.now().strftime('%Y%m%d')}.log"
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open(log_file, "a", encoding="utf-8") as f:
        f.write(f"[{timestamp}] {action}: {details}\n")


# --- Scheduled Tasks ---

def run_ceo_briefing():
    """Generate CEO Monday Morning Briefing."""
    try:
        from ceo_briefing_generator import generate_briefing
        filepath = generate_briefing()
        log_activity("CEO_BRIEFING", f"Generated: {filepath}")
        print(f"  [SCHEDULER] CEO Briefing generated: {filepath}")
    except Exception as e:
        log_activity("ERROR", f"CEO Briefing failed: {e}")
        print(f"  [SCHEDULER] CEO Briefing error: {e}")


def run_subscription_audit():
    """Run subscription cost audit."""
    try:
        from ceo_briefing_generator import parse_transactions, detect_unused_subscriptions
        _, _, subscriptions = parse_transactions()
        unused = detect_unused_subscriptions(subscriptions)

        audit_dir = VAULT_DIR / "Accounting"
        audit_dir.mkdir(parents=True, exist_ok=True)
        now = datetime.now()

        total_sub_cost = sum(s["amount"] for s in subscriptions)

        report = f"""---
generated: {now.isoformat()}
type: subscription_audit
---

# Subscription Audit - {now.strftime('%Y-%m-%d')}

## Active Subscriptions

| Service | Monthly Cost | Last Charged |
|---------|-------------|-------------|
"""
        for sub in subscriptions:
            report += f"| {sub['name']} | ${sub['amount']:.2f} | {sub['date']} |\n"

        report += f"""
**Total Monthly Subscriptions**: ${total_sub_cost:.2f}

## Optimization Suggestions
"""
        if unused:
            for sub in unused:
                report += f"- **{sub['name']}**: Low/no activity detected. Cost: ${sub['amount']:.2f}/month. Consider cancelling.\n"
        else:
            report += "- No unused subscriptions detected this period.\n"

        report += f"""
---
*Generated by AI Employee Scheduler at {now.strftime('%Y-%m-%d %H:%M:%S')}*
"""

        audit_path = audit_dir / f"Subscription_Audit_{now.strftime('%Y-%m-%d')}.md"
        audit_path.write_text(report, encoding="utf-8")
        log_activity("SUBSCRIPTION_AUDIT", f"Generated: {audit_path}")
        print(f"  [SCHEDULER] Subscription Audit generated: {audit_path}")

    except Exception as e:
        log_activity("ERROR", f"Subscription Audit failed: {e}")
        print(f"  [SCHEDULER] Subscription Audit error: {e}")


def run_daily_summary():
    """Generate daily activity summary in Logs."""
    try:
        now = datetime.now()
        done_dir = VAULT_DIR / "Done"
        needs_dir = VAULT_DIR / "Needs_Action"
        plans_dir = VAULT_DIR / "Plans"

        done_count = sum(1 for _ in done_dir.glob("*.md")) if done_dir.exists() else 0
        needs_count = sum(1 for d in needs_dir.iterdir() if d.is_dir()
                         for _ in d.glob("*.md")) if needs_dir.exists() else 0
        plans_count = sum(1 for _ in plans_dir.glob("*.md")) if plans_dir.exists() else 0

        summary = (
            f"[{now.isoformat()}] DAILY SUMMARY: "
            f"Done={done_count}, Needs_Action={needs_count}, Plans={plans_count}\n"
        )

        log_file = LOGS_DIR / f"daily_summary_{now.strftime('%Y%m%d')}.log"
        with open(log_file, "a", encoding="utf-8") as f:
            f.write(summary)

        log_activity("DAILY_SUMMARY", f"Done={done_count}, Needs_Action={needs_count}")
        print(f"  [SCHEDULER] Daily summary logged")

    except Exception as e:
        log_activity("ERROR", f"Daily summary failed: {e}")


# --- Schedule Engine ---

class SimpleScheduler:
    """Lightweight scheduler using time-of-day checks."""

    def __init__(self):
        self.last_runs = {}

    def should_run(self, task_name, day_of_week=None, hour=None, interval_hours=None):
        """
        Check if a task should run.
        - day_of_week: 0=Monday, 6=Sunday (None = any day)
        - hour: hour of day to run (None = any hour)
        - interval_hours: minimum hours between runs
        """
        now = datetime.now()
        last = self.last_runs.get(task_name)

        # Check day of week
        if day_of_week is not None and now.weekday() != day_of_week:
            return False

        # Check hour
        if hour is not None and now.hour != hour:
            return False

        # Check interval
        if interval_hours and last:
            if (now - last).total_seconds() < interval_hours * 3600:
                return False

        # Don't re-run within same minute
        if last and (now - last).total_seconds() < 60:
            return False

        return True

    def mark_run(self, task_name):
        self.last_runs[task_name] = datetime.now()


def main():
    LOGS_DIR.mkdir(parents=True, exist_ok=True)

    scheduler = SimpleScheduler()

    print("=" * 60)
    print("  AI Employee - Scheduler LIVE MODE")
    print(f"  Check Interval: {CHECK_INTERVAL}s")
    print("  Scheduled Tasks:")
    print("    - CEO Monday Briefing: Sunday 21:00")
    print("    - Subscription Audit: Weekly (Friday 18:00)")
    print("    - Daily Summary: Every day at 23:00")
    print("    - On-demand: CEO Briefing also runs on first start")
    print("=" * 60)
    print()

    log_activity("STARTED", "Scheduler started")

    # Run CEO briefing once on first startup (useful for demos)
    print("  [SCHEDULER] Running initial CEO Briefing on startup...")
    run_ceo_briefing()
    scheduler.mark_run("ceo_briefing")

    # Run subscription audit on startup too
    print("  [SCHEDULER] Running initial Subscription Audit on startup...")
    run_subscription_audit()
    scheduler.mark_run("subscription_audit")

    while running:
        now = datetime.now()

        # CEO Monday Briefing - Sunday at 21:00 (so it's ready Monday morning)
        if scheduler.should_run("ceo_briefing", day_of_week=6, hour=21):
            print(f"\n  [SCHEDULER] Triggering CEO Monday Briefing...")
            run_ceo_briefing()
            scheduler.mark_run("ceo_briefing")

        # Subscription Audit - Friday at 18:00
        if scheduler.should_run("subscription_audit", day_of_week=4, hour=18):
            print(f"\n  [SCHEDULER] Triggering Subscription Audit...")
            run_subscription_audit()
            scheduler.mark_run("subscription_audit")

        # Daily Summary - Every day at 23:00
        if scheduler.should_run("daily_summary", hour=23):
            print(f"\n  [SCHEDULER] Triggering Daily Summary...")
            run_daily_summary()
            scheduler.mark_run("daily_summary")

        for _ in range(CHECK_INTERVAL):
            if not running:
                break
            time.sleep(1)

    log_activity("STOPPED", "Scheduler stopped")
    print("[Scheduler] Stopped.")


if __name__ == "__main__":
    main()
